## 读算法小抄有感

### 动态规划问题

 解决动态规划问题的核心就是写出状态转移方程。重点是画出递归树，也就是分割的子问题的集合。

通过递归树来查看暴力解法的算法复杂度。在没有循环下一般问题的一个子问题的时间复杂度就是O(1)

对于一个问题：斐波那契数列来说，想要算出n>3以上的值，那么就要去寻找以前算出的值。画出递归树：

![](https://s3.ax1x.com/2020/11/23/DY5ZtS.png)

二叉树的节点个数就是暴力算法时间复杂度。也就是O(2^n)

补一下二叉树的性质：

性质1：在二叉树的第i层上至多有2^i－1个结点（i≥1）。//减一是因为第一个节点问题。如果没有就是2^2

性质2：深度为k的二叉树上至多含2^k－1个结点（k≥1）。

性质2：对任意一棵二叉树T，若终端结点数为n0，而其度数为2的结点数为n2，则n0＝n2＋1。

性质4：具有n个结点的完全二叉树的深度为"log2n#＋1或$log2（n＋1）%，其中"log2n#表示取小于等于"log2n#的整数部分，$log2（n＋1）%表示取大于等于log2（n＋1）的整数部分。

性质5：对一棵具有n个结点的完全二叉树从上到下且从左至右按层序编号，则对二叉树中任意一个编号为i（1≤i≤n）的结点有：

（1）如果i＞1，则结点i的双亲结点的序号为"i／2#；如果i＝1，则结点i是根结点，无双亲结点；

（2）如果2i≤n，则结点i的左孩子的序号为2i，如果2i＞n，则结点i无左孩子。

（2）如果2i＋1≤n，则结点i的右孩子的序号为2i＋1，如果2i＋1＞n，则结点i无右孩子。

当然这个问题我们可以写一个递归来解决这个问题：

```java
int fib(int N) {
if (N == 1 || N == 2) return 1;
return fib(N - 1) + fib(N - 2);
}
```

但有个问题，这个递归居然是一个个算的暴力...也就是说，我从fib(4)开始，想要算fib(4)就要算一下f(3)

如此递归，形成递归树。但是我们是可以进行简化算法，因为我们可以把算过一次的数放进一个集合，这样就可以提高算法复杂度，也就是什么？也就是动态规划的第一个目标：**解决重叠子问题的目标**

我们可以创造一个数据字典（数组、集合类）存放已经算过的函数，这样就可以直接拿出来用等第二次进行运算的时候。

```java
 //数据字典
    public static int fib1(int N){
        if (N<1) return 0;
        int[] memo = new int[N+1];
        return helper(memo,N);
    }
    public static int helper(int[] mego,int n){
        if (n == 1 || n == 2) return 1;
        if (mego[0]!=0) return mego[n];
        mego[n] = helper(mego,n-1)+
                helper(mego,n-2);
        return mego[n];
    }
```



解决一个子问题的时间,同上,没有什么循环,时间为 O(1)。
所以,本算法的时间复杂度是 O(n)。比起暴力算法,是降维打击

但此时还是真正意义上的动态规划问题，因为动态规划是自底向上而此方法是自顶向下

继续来晚上动态规划问题：我们将这个数组称为dp数组：DP table。我们现在致力于完善这个自底向上表

