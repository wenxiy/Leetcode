## 数据结构基础

* 数据结构的含义
* 大体分类
* 关于练习
* 一个和分享无关但是想讲的事情

### 什么是数据结构？

数据之间的关系就是数据结构。也就是对象之间的关系，你也可以说他是一种多种关系元素的集合。

记得是一种集合的关系。

### 大体分类

那么对于集合的关系，我们首先能想到什么？我们首先要定义一个这个集合在计算机中如何存储

* 数组
* 链表

可能学过（划掉）数据结构的会说，为什么只有这两种分类？因为数组是一种顺序的实现，但是它存在一个问题，就是容量的问题。而链表是一种链式存储，但它需要一个内存空间的问题。

那么树算什么呢？对于一个数据结构，我们知道是有二叉树的。那么首先二叉树是怎么定义的？

* 定义：二叉树是一种非线性数据结构，将集合元素利用**分支**关系组织起来的结构。

所以我们不说这些抽象的东西，我们说一个具体的：

![](https://s1.ax1x.com/2020/11/01/BdnexJ.png)

这个图就是一个典型的二叉树。如果具体的定义包括一些名词解释，就看看石泽远学长的博客，讲的很清楚

所以说二叉树是什么？一种分支关系，那么就可以说是一种链式存储。所以堆栈同理。

那么对于复杂度来说呢？

如果是数组来实现的数据结构，那么他的复杂度就是O(N),对数组进行操作必须搬移前后之间的数据，那么时间复杂度还是O(N)(程序语句执行次数的频度，原则是最坏情况简化法)（关于复杂度：<http://data.biancheng.net/view/272.html>）

如果是链表来实现的数据结构，如果知道某一元素的前驱和后驱,操作指针即可删除该元素或
者插入新元素,时间复杂度 O(1)

O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n2)平方阶 < O(n3)(立方阶) < O(2n) (指数阶）

#### 关于练习（一点小递归的思考）

那么我们了解了基础的知识，有了一些C语言的基础，应该从哪个方面来做算法题？

显然是二叉树，二叉树对于算法思想，递归等有很多思考。所以我们从二叉树入手。

讲到二叉树就必然要讲到递归：

![](https://s1.ax1x.com/2020/11/01/BdK52F.png)



核心思想：在A函数中调用一个B函数，在运行时调用，但是这个B函数就是A函数本身。

那么就会有如下伪代码和分析：

![](https://s1.ax1x.com/2020/11/01/BdMEPf.png)

但是有个问题，这个函数会不会停止？当然不会，因为f(0)知道了，那么f(-1.)呢？似乎无穷无尽的走了下去

我们再加一个限制条件

![](https://s1.ax1x.com/2020/11/01/BdMlaq.png)

所以这个就是递归的核心，也是递归三要素：

* **第一要素：明确你这个函数想要干什么**
* **第二要素：寻找递归结束条件**
* **第三要素：找出函数的等价关系式**

那么我们现在分析二叉树。（上面的三要素可以试着分析一下三个要素分别是什么

二叉树是一种递归的定义，递归这种算法是十分重要的。递归也有点类似动态规范等。

```c
struct binary_tree {//二叉树的定义
    int data    ;   // Data area
    struct binary_tree * left; //指向左边子树的指针域
    struct binary_tree * right;//指向右边子树的指针域
};

struct binary_tree * tree;//实例化
```

#### 一个和分享无关但是想讲的事情

我们说过，函数A调用函数B时，当B=A的时候就是递归。也就是函数自己调用自己。那么我们通过这个特例，可以知道函数是可以调用函数的，如果B≠A呢？将会发生什么？那这种又叫什么呢

其实，这样是可以实现的，但是是有条件的：函数调用函数，参数值必须是函数指针（地址）。这种调用又称为回调。

那么我们再深入一点，这种的作用是什么呢？

把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。关于同步和异步，这里不作讨论，请查阅相关资料。（维基百科的定义）

最后我们来想一个问题，C语言是通过指针来找到地址

```C
#include <stdio.h>
 
void PrintNum(int n);
void ShowNum(int n,void (* ptr)());
 
void PrintMessage1();
void PrintMessage2();
void PrintMessage3();
void ShowMessage(void (* ptr)());
 
int main(){
   ShowNum(11111,PrintNum);
   ShowNum(22222,PrintNum);
   ShowMessage(PrintMessage1);
   ShowMessage(PrintMessage2);
   ShowMessage(PrintMessage3);
}
 
void PrintNum(int n){
   printf("Test1 is called,the number is %d\n",n);
}
 
void ShowNum(int n,void (* ptr)()){
   (* ptr)(n);
}
 
 
void PrintMessage1(){
   printf("This is the message 1!\n");
}
 
void PrintMessage2(){
   printf("This is the message 2!\n");
}
 
void PrintMessage3(){
   printf("This is the message 3!\n");
}
 
void ShowMessage(void (* ptr)()){
    (* ptr)();
}
```



那么Java呢？Java是如何进行回调？

我们知道，在Java中引用是可以代表一个地址，也就是代替了指针。

所以我们可以通过传引用来进行调用。这个就不深入了，大家用到的时候会看到。